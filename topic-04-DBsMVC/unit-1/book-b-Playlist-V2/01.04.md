# Datenbank Integration

Um eine Verbindung zur Datenbank hinzuzufügen erstellen wir ein neues Model und verarbeiten darin die gesamte *Connection*.

## Model hinzufügen

Erstellen Sie die Datei `data-store.js` im Ordner `models` und fügen Sie darin folgenden Code ein:

```js
var pg = require("pg");
const logger = require("../utils/logger.js");

const conString = process.env.DB_CON_STRING;

const dbConfig = {
  connectionString: conString,
  ssl: { rejectUnauthorized: false }
}

if (conString == undefined) {
  logger.error("ERROR: environment variable DB_CON_STRING not set.");
  process.exit(1);
}

let dbClient = null;

const dataStore = {
  getDataStore() {
    if (dbClient !== null) {
      return dbClient;
    } else {
      dbClient = new pg.Client(dbConfig);
      dbClient.connect();
      return dbClient;
    }
  },
  async endConnection() {
    await dbClient.end();
  }
}

module.exports = dataStore;
```

Dieses Modul stellt die Verbindung zur Datenbank her und exportiert das Objekt `dataStore`, für die späteren Models der Web-App.

## Connection String

Die Datei `data-store.js` versucht auf die Datenbank Credentials mittels der folgenden Zeile zuzugreifen:

```js
const conString = process.env.DB_CON_STRING;
```

Damit diese Variable in *replit* ausgelesen werden kann, gehen Sie wie folgt vor:

* Klicken Sie auf der linken Seite auf das Schloss (Secrets)
* Fügen Sie eine neue Umgebungsvariable ein
  * Der key ist `DB_CON_STRING` (vgl. oben)
  * Der value ist in Heroko als `URI` unter den Database Credentials hinterlegt.

Nun kann die Web-App zwar prinzipiell eine Verbindung zur Datenbank aufbauen, der Code wird aber bis jetzt noch nicht verwendet, da die Daten immer noch aus dem statischen Model `playlist-store.js` abgefragt werden. Daher ändern wie diese nun von einem statischen Speicher in eine dynamische Abfrage.

## Datenbank nutzen

Ersetzen Sie dann den Code der Datei `playlist-store.js` im Ordner Models durch den folgenden Code:

```js
const dataStore = require("./data-store.js");
const dataStoreClient = dataStore.getDataStore();
const logger = require("../utils/logger.js");

const playlistStore = {
  async getAllPlaylists() {
    const query = 'SELECT * FROM playlist2_playlists';
    try {
      let result = await dataStoreClient.query(query);
      return result.rows;
    } catch (e) {
      logger.error("Error fetching all playlists", e);
    }
  },
};

module.exports = playlistStore;
```

Somit frägt das Model `playlist-store.js` jetzt die Daten immer direkt von der Datenbank, unter der Verwendung des Moduls `data-store.js`, ab statt ein statisches Array zu nutzen.

Jetzt muss der Controller des Dashboards angepasst werden, um das neue Model zu verwenden.

Passen Sie dazu den Controller des Dashboards (`dashboard.js`) wie folgt an:

```js
const logger = require("../utils/logger.js");
const playlistStore = require("../models/playlist-store.js");

const dashboard = {
  async index(request, response) {
    logger.info("dashboard rendering");
    const playLists = await playlistStore.getAllPlaylists();
    const viewData = {
      title: "Dashboard",
      playlists: playLists
    };
    logger.info('about to render', playLists);
    response.render("dashboard", viewData);
  }
};

module.exports = dashboard;
```

Starten Sie die App neu (dazu auf der Shell ggf. vorher `Strg + C` drücken) und dann den folgenden Befehl eingeben:

```shell
node app.js
```

Die App sollte aussehen wie zuvor, mit dem Unterschied, dass die Daten jetzt aus der *PostgreSQL*-Datenbank von *Heroku* abgefragt werden.

## Rubber Duck Debugging

Versuchen Sie jetzt nachzuvollziehen was ab dem Request auf die Route `/dashbord` in Ihrer App passiert und testen Sie Ihre App ausführlich.

Erklären Sie den Ablauf Ihrem Nachbarn beziehungsweise Ihrer Nachbarin (Stichwort: *Rubber Duck Debugging*).
